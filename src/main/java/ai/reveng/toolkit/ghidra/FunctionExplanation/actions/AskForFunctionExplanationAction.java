package ai.reveng.toolkit.ghidra.FunctionExplanation.actions;

import ai.reveng.toolkit.ghidra.ReaiPluginPackage;
import ai.reveng.toolkit.ghidra.core.services.api.GhidraRevengService;
import ai.reveng.toolkit.ghidra.core.services.logging.ReaiLoggingService;
import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.MenuData;
import ghidra.app.decompiler.ClangTokenGroup;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileOptions;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.plugin.core.decompile.DecompilerActionContext;
import ghidra.app.services.ProgramManager;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;

import javax.help.UnsupportedOperationException;

public class AskForFunctionExplanationAction extends DockingAction {

	private PluginTool tool;
	private Function fau;
	private GhidraRevengService apiService;
	private ReaiLoggingService loggingService;

	public AskForFunctionExplanationAction(PluginTool tool) {
		super("CustomDecompilerAction", tool.getName());
		setPopupMenuData(new MenuData(new String[] { "Explain this function" }, ReaiPluginPackage.NAME));
		this.tool = tool;
		loggingService = tool.getService(ReaiLoggingService.class);
		if (loggingService == null) {
			Msg.error(this, "Unable to access logging service");
		}
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		if (!(context instanceof DecompilerActionContext)) {
			return false;
		}

		return true;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		if (!(context instanceof DecompilerActionContext)) {
			return;
		}

		DecompilerActionContext decompilerContext = (DecompilerActionContext) context;
		DecompInterface decompiler = new DecompInterface();
		ProgramManager programManager = tool.getService(ProgramManager.class);
		Program currentProgram = programManager.getCurrentProgram();

		decompiler.openProgram(currentProgram);

		boolean initialized = decompiler.openProgram(currentProgram);
		if (!initialized) {
			loggingService.error("Failed to initialize DecompInterface");
			return;
		}

		this.fau = currentProgram.getFunctionManager().getFunctionAt(decompilerContext.getAddress());

		if (this.fau == null) {
			loggingService.error("No function at given address");
			return;
		}

		DecompileOptions options = decompiler.getOptions();
		if (options == null) {
			options = new DecompileOptions();
			decompiler.setOptions(options);
		}

		int timeout = options.getDefaultTimeout();

		DecompileResults results = decompiler.decompileFunction(this.fau, timeout, null);
		loggingService.info("Decomp:\n\n" + results.toString());

		if (!results.decompileCompleted()) {
			loggingService.error("Issue decompiling function");
			return;
		}

		ClangTokenGroup decompiledFunction = results.getCCodeMarkup();

		apiService = tool.getService(GhidraRevengService.class);
//		Object res = apiService.explain(decompiledFunction.toString());
		throw new UnsupportedOperationException("FunctionExplaination not implemented yet");
//		if (res.getJsonObject().has("error")) {
//			loggingService.error("Error with function explaination: " + res.getJsonObject().get("error").toString());
//			Msg.showError(this, null, "", "Error getting function explaination: " + res.getJsonObject().get("error"));
//			return;
//		}
//
//		int transactionID = currentProgram.startTransaction("Set function pre-comment based on RevEng.ai description");
//		String fComment = String.format("RevEng.AI Autogenerated\n\n%s", res.getJsonObject().getString("explanation"));
//		fau.setComment(fComment);
//		currentProgram.endTransaction(transactionID, true);
//		loggingService.info(fComment);
	}
}